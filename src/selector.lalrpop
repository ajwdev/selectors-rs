use ast::{Expr, Operator, LabelKey, LabelValue, Selector};

// See https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set

grammar;

pub Selector: Selector<'input> = {
    // There is a feature request out there to add `mut` keyword to LALRPOP. Key
    // an eye out and adjust to use .append here instead of ::combine
    <Selector> "," <Expr> => Selector::combine(<>),
    Expr => Selector::new(vec![<>]),
}

Expr: Box<Expr<'input>> = {
    LabelKey ExprOp LabelValue => Box::new(Expr::Op(<>)),
    "!" <LabelKey> => Box::new(Expr::NotExists(<>)),
    LabelKey => Box::new(Expr::Exists(<>)),
}

ExprOp: Operator = {
    r"=?=" => Operator::Equal,
    "!=" => Operator::NotEqual,
}

pub LabelKey: Box<LabelKey<'input>> = {
    KeyWithPrefix => {
        // KeyWithPrefix should not allow patterns with multiple "/" so
        // this should be safe. Still a little gross though
        let groups: Vec<&str> = <>.split("/").collect();
        Box::new(LabelKey::WithPrefix(groups[0], groups[1]))
    },
    KeyOrValue => Box::new(LabelKey::NoPrefix(<>)),
}

pub LabelValue: Box<LabelValue<'input>> = {
    KeyOrValue => Box::new(LabelValue::Value(<>)),
}

// Removes ambiquity in the parser between keys with prefixes and values/prefixless keys.
// Example: "example.com/foo" versus just "foo"
//
// Code related to label validation can be found below.
// https://github.com/kubernetes/apimachinery/blob/521145febf93d5639dce48a49ee8dc080863b034/pkg/util/validation/validation.go#L126
match {
    r"(?i)([a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*){1,253}/([a-z0-9][-._a-z0-9]+[a-z0-9]){1,63}" => KeyWithPrefix,
} else {
    r"(?i)([a-z0-9][-._a-z0-9]+[a-z0-9]){1,63}" => KeyOrValue,
    _
}
